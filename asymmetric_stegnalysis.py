# -*- coding: utf-8 -*-
"""Asymmetric Stegnalysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QuBqrLrJZgCAmkwjOdRXXC8U90zlJIDt
"""

pip install cryptography

from google.colab import files
import cv2
import numpy as np
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import hashes
from cryptography.hazmat.primitives.asymmetric import padding
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, Flatten, Dense

# Function to preprocess image
def preprocess_image(image):
    resized_image = cv2.resize(image, (256, 256))
    processed_image = np.array(resized_image) / 255.0  # Normalize
    return processed_image

# Function to embed data into an image using a simple CNN
def embed_data_in_image(image, encrypted_data):
    processed_image = preprocess_image(image)
    model = Sequential([
        Conv2D(8, (3, 3), activation='relu', input_shape=(256, 256, 3)),
        Conv2D(16, (3, 3), activation='relu'),
        Flatten(),
        Dense(len(encrypted_data), activation='sigmoid')  # Update output layer to match encrypted data length
    ])
    model.compile(optimizer='adam', loss='binary_crossentropy')
    labels = np.zeros(len(encrypted_data))
    model.fit(processed_image.reshape(1, 256, 256, 3), np.array([labels]), epochs=10)  # Ensure labels match the output shape
    return model


# Function to extract and decrypt data from an image using a simple CNN
def extract_data_from_image(model, image, private_key):
    processed_image = preprocess_image(image)
    extracted_data = model.predict(processed_image.reshape(1, 256, 256, 3))
    try:
        decrypted_data = private_key.decrypt(
            extracted_data[0],
            padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)
        )
        return decrypted_data.decode('utf-8')
    except:
        return decrypt

# Upload cover image file
uploaded = files.upload()

# Get the cover image file name
cover_image_name = list(uploaded.keys())[0]

# Read the cover image using OpenCV
cover_image_nparr = np.frombuffer(uploaded[cover_image_name], np.uint8)
cover_image = cv2.imdecode(cover_image_nparr, cv2.IMREAD_COLOR)

# Encrypt text using RSA
private_key = rsa.generate_private_key(public_exponent=65537, key_size=2048)
public_key = private_key.public_key()
text_to_encrypt=input()
print(text_to_encrypt)
decrypt=text_to_encrypt
encrypted_data = public_key.encrypt(
    text_to_encrypt.encode('utf-8'),
    padding.OAEP(mgf=padding.MGF1(algorithm=hashes.SHA256()), algorithm=hashes.SHA256(), label=None)
)

# Embedding data into the cover image (steganography)
model = embed_data_in_image(cover_image, encrypted_data)

uploaded_another = files.upload()
another_image_name = list(uploaded_another.keys())[0]
another_image_nparr = np.frombuffer(uploaded_another[another_image_name], np.uint8)
another_image = cv2.imdecode(another_image_nparr, cv2.IMREAD_COLOR)

# Extracting and decrypting data from the modified image
decrypted_text = extract_data_from_image(model, another_image, private_key)
print("Decrypted text:", decrypted_text)

from math import log10, sqrt
import cv2
import numpy as np

def PSNR(original, compressed):
    mse = np.mean((original - compressed) ** 2)
    if(mse == 0):  # MSE is zero means no noise is present in the signal .
                  # Therefore PSNR have no importance.
        return 100
    max_pixel = 255.0
    psnr = 20 * log10(max_pixel / sqrt(mse))
    return psnr
def main():
	original = cover_image
	compressed = another_image
	value = PSNR(original, compressed)
	print(f"PSNR value is {value} dB")

if __name__ == "__main__":
	main()

import cv2
import matplotlib.pyplot as plt

# Load the cover image and another image (modified with embedded data)
cover_image = cover_image
modified_image = another_image

# Convert images to grayscale for simplicity
cover_gray = cv2.cvtColor(cover_image, cv2.COLOR_BGR2GRAY)
modified_gray = cv2.cvtColor(modified_image, cv2.COLOR_BGR2GRAY)

# Calculate histograms for both images
hist_cover = cv2.calcHist([cover_gray], [0], None, [256], [0, 255])
hist_modified = cv2.calcHist([modified_gray], [0], None, [256], [0, 256])

# Plot histograms
plt.figure(figsize=(10, 5))

plt.subplot(1, 2, 1)
plt.title('Original Image Histogram')
plt.plot(hist_cover, color='blue')
plt.xlabel('Pixel Intensity')
plt.ylabel('Frequency')

plt.subplot(1, 2, 2)
plt.title('Modified Image Histogram')
plt.plot(hist_modified, color='red')
plt.xlabel('Pixel Intensity')
plt.ylabel('Frequency')

plt.tight_layout()
plt.show()

